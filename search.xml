<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何阅读期刊论文</title>
      <link href="/2020/06/12/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E6%9C%9F%E5%88%8A%E8%AE%BA%E6%96%87/"/>
      <url>/2020/06/12/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E6%9C%9F%E5%88%8A%E8%AE%BA%E6%96%87/</url>
      
        <content type="html"><![CDATA[<p>技术的创新并不是全靠聪明。只要<strong>学会分析期刊论文的优缺点</strong>，就可拿这套方法分析竞争对手产品的优缺点；而且，只要再稍微加工，就可以从这套优缺点的清单里找到突破瓶颈所需的关键性创意。这套创新程序，可以把「创新」变成不需要太多天分便可以完成的事，从而减轻创意的不定性与风险性。因此，只要会分析论文，几乎就可以轻易地组合出你所需要的绝大部分创意。聪明是不可能教的，但这套技巧却是可以教的；而且只要用心，绝大部分硕士生都可以学会。</p><h1 id="期刊论文的分析技巧与程序"><a href="#期刊论文的分析技巧与程序" class="headerlink" title="期刊论文的分析技巧与程序"></a>期刊论文的分析技巧与程序</h1><p>一篇期刊论文，主要分成四个部分。</p><h2 id="1-Abstract"><a href="#1-Abstract" class="headerlink" title="1. Abstract"></a>1. Abstract</h2><p>涉及这篇论文的主要贡献、方法特色与主要内容。须学会只看Abstract和Introduction就判断出这篇论文的重点和自己的研究是否有直接关联，从而决定要不要把它给读完。</p><h2 id="2-Introduction"><a href="#2-Introduction" class="headerlink" title="2. Introduction"></a>2. Introduction</h2><p>介绍问题的背景和起源，交代前人在这个题目上已经有过的主要贡献，说清楚前人留下来的未解问题，以及在这个背景下这篇论文想解决的问题和它的重要性。</p><p>对初学者而言，先收集与课题相关的论文30~40篇，每篇都只读Abstract和Introduction，不读Main Body，只在必要时稍微参考一下文后的Illustrative examples和Conclusions，直到能回答以下三个问题：</p><p>（2A）在该领域内最常被引述的方法有哪些？</p><p>（2B）这些方法可以分成哪些主要派别？</p><p>（2C）每个派别的主要特色（含优点和缺点）是什么？</p><p>如何找到这30~40篇论文？有一种期刊论文叫review paper，在keywords中加一个review筛选出这类论文，从相关的数篇review paper开始，从中根据title和Abstract找出和自己研究课题相关的30~40篇论文。</p><p>通常反复读过这30~40篇论文的Abstract和Introduction，就可以回答（2A）和（2B）。要回答（2A）和（2B），应先挑那些Introduction写的比较有观念的论文（不要直接读写得像流水账的Introduction）。</p><p>假如读过30~40篇论文的Abstract和Introduction后，还是回答不了（2C），就先做以下工作：</p><ul><li>先根据（2A）的答案，把该领域内最常被引述的论文找齐，再把他们根据（2B）的答案分成派别，每个派别按日期先后次序排好。然后，每次只重新读一派的Abstract和Introduction（必要时简略参考内文，但目的只是读懂Introduction内与这派有关的陈述，而不需要真的看懂所有内文），照日期先后读，读的时候只考虑回答一个问题：这一派的创意和主要诉求是什么？这样把每一派的Abstract和Introduction读完，总结出这一派主要的诉求、方法特色和优点。</li><li>其次，重读前面这些论文的Introduction，回答问题：每篇论文对其他派别有什么批评？然后把读到的重点逐一记录到各派别的<strong>缺点</strong>栏内。</li></ul><p>通过以上程序，可以掌握到（2A）、（2B）和（2C）的答案。这时应该对该领域内主要方法、文献之间的关系比较熟悉了。此时，可以用这些论文测试看看之前用来搜寻该领域论文的keywords恰不恰当，再用修正过的keywords再搜寻一次论文，把该领域的主要文献补齐，也把原来30~40篇论文中关系较远的论文删除，只保留大概20篇左右确定跟自己关系较近的文献。甚至可以删除几个不想用的派别（要有充分理由），只保留另几个派别（也要有充分理由）。</p><p>然后再利用（2C）的答案，再进一步回答一个问题（2D）：<strong>这个领域内大家认为重要的关键问题有哪些？有哪些特性是大家重视的优点？有哪些特性是大家在意的缺点？这些优点与缺点通常在哪些应用场合时会比较被重视？在哪些应用场合时比较不会被重视？</strong>然后就可以整理出该领域主要的应用场合，以及这些应用场合上该注意的事项。</p><p>最后，根据（2A）和（2C）的答案，把各派别内的论文整理在同一个档案内，按时间顺序排好，然后依照这些派别与自己研究方向的关系远近，逐一把各派论文的Main Body读完。</p><h2 id="Main-Body（simulation-and-experimental-examples"><a href="#Main-Body（simulation-and-experimental-examples" class="headerlink" title="Main Body（simulation and experimental examples)"></a>Main Body（simulation and experimental examples)</h2><p>第一次有系统地读某派别的论文Main Body时，只需要读懂：</p><p>（3A）该论文的主要假设是什么（什么条件下是有效的），并评估下这些假设在现实条件下成立的难度。越难成立的假设，越不好用，参考价值也越低。</p><p>（3B）在这些假设下，这篇论文主要有什么好处。</p><p>（3C）这些好处主要表现在哪些公式的哪些项目的简化上。不需要懂这篇论文详细的推导过程。除了三、五个关键的公式（最后在应用上要使用的公式，可以从这些公式评估出该方法使用上的方便程度或计算效率，以及在非理想情境下这些公式使用起来的可靠度或稳定性），其他公式弄不懂也没事，公式之间的恒等式推导过程可完全略过。假如要看公式，重点应看公式推导过程中引入的假设条件，而不是恒等式的推导。</p><p>但是，在开始根据前述问题读论文前，应先把收集的该派别所有论文都拿出来，逐篇粗略浏览过去（不要勉强自己每篇或每行都弄懂，而是轻松读，能懂就懂，不懂就不懂），从中挑出容易读懂的papers，以及经常被引述的论文。然后把这些论文按时间顺序依次读下去。读的时候，记得只回答（3A）、（3B）、（3C）就好，不用读太细致。</p><p>这样读完论文后，应该把这一派的主要发展过程、主要假设、主要理论依据及主要成果做一个完整梳理。其次，还要根据（2D）的答案及这一派的主要假设，进一步回答问题：（3D）这一派主要的缺点有哪些。最后，根据（3A）、（3B）、（3C）、（3D）的答案综合整理出：这一派最适合什么时候使用，最不适合什么场合使用。</p><p>论文作者常常故意只提成功的实验案例，所以simulation examples and experiments表现好不代表这个方法真的很好。必须回到这个方法的基本假设以及在用该方法时所使用的主要公式（resultant equations)上去，参考（2C）和（2D）的答案，问自己：当某个假设无法成立时，该方法会不会出什么状况？猜测该方法应该会在哪些应用场合表现优异，又会在哪些应用场合出状况？根据猜测再检验一次simulation examples and experiments，看其优点和缺点是否确实在这些examples中被充分检验且充分表现出来。</p><p>==注==：任何时候都不需要弄懂一篇论文所有的恒等式推导过程，不需要把整篇论文细细读完，只需要把确定会用到的部分完全弄懂就好，其他的也只需要了解它主要的idea。</p><p><img src="http://images.cnitblog.com/i/326116/201403/211603473659485.png" alt="img"></p><h1 id="方法与应用场合特性表（有迹可寻的创意产生程序）"><a href="#方法与应用场合特性表（有迹可寻的创意产生程序）" class="headerlink" title="方法与应用场合特性表（有迹可寻的创意产生程序）"></a>方法与应用场合特性表（有迹可寻的创意产生程序）</h1><p>从上图的步骤（4）和（5）获得以下两张表：</p><p><img src="http://images.cnitblog.com/i/326116/201403/211602235683420.png" alt="img"></p><p>同样一个方法可能有许多不同的应用场合，而不同应用场合可能会对适用（或最佳）的方法有不同要求。<strong>方法没有好坏，只有相对优缺点；只有当方法的特性与应用场合的特性不合时，才能下结论说这方法「不适用」；而当方法的特性与应用场合的特性吻合时，则下结论说这方法「很适用」。</strong></p><p>==技巧==：上面的方法与问题分析对照表还可以用来把「突破瓶颈所需的创意」简化成一种「有迹可寻」的工作。譬如，假定我们要针对应用甲发展一套适用的方法，首先我们要先从上右表中标定这个应用场合关心哪些问题特性。根据上右表第一个 column，甲应用场合只关心四个特性：特性1、2、3、5。哪个方法最适用呢？看起来是方法一，它除了特性2表现普通之外，其它三个特性的表现都很出色。但是，假如我们对方法一的表现仍不够满意，怎么去改善它？最简单的办法就是从上左表找现成的方法和方法一结合，产生出一个更适用的方法。因为方法一只有在特性2上面表现不够令人满意，所以我们就优先针对在特性2上面表现出色的其它方法加以研究。根据上左表，在特性2上面表现出色的方法有方法二和方法四，所以我们就去研究这两个方法和方法一结合的可能性。或许（随便举例）方法四的创意刚好可以被结合进方法一而改善方法一在特性2上面的表现，那么，我们就可以因此轻易地获得一个方法一的改良，从而突破甲应用场合没有适用方法的瓶颈。</p><p><strong>多半时候只要应用上一段的分析技巧就可以产生足以解决实用问题的创意了。</strong></p><h1 id="论文阅读的补充说明"><a href="#论文阅读的补充说明" class="headerlink" title="论文阅读的补充说明"></a>论文阅读的补充说明</h1><p>不好的习惯：</p><p>（1）老是想逐行读懂，有一行读不懂就受不了。</p><p>（2）不敢发挥自己的想象，读论文像在读教科书，论文没写的就不会，瘫痪在那里；自己猜测或想象时，老怕弄错作者的意思，神经绷紧，脑筋根本动不了。</p><p>==注==：每次读论文都一定要带着问题去读，每次读的时候都只是图回答你要回答的问题。因此，一定是选择性地阅读，一定要逐渐由粗而细地一层一层去了解。一定是一整批一起读懂到某个层次，而不是逐篇逐篇地整篇一次读懂。</p><p>许多论文中没被交代的段落你也已经可以有一些属于你的想象，猜完以后要根据你的猜测在论文里找证据，用以判断你的猜测对不对。猜对了，就用你的猜测（其实是你的推理架构）去吸收作者的资讯与创意；猜错了，论文理会有一些信息告诉你说你错了，而且因为猜错所以你读到对的答案时反而印象更深刻。</p><h1 id="论文报告的要求与技巧"><a href="#论文报告的要求与技巧" class="headerlink" title="论文报告的要求与技巧"></a>论文报告的要求与技巧</h1><p>报告一篇论文（依报告次序排列）：</p><p>　　（1） 投影片第一页必须列出论文的题目、作者、论文出处与年份。</p><p>　　（2） 以下每一页投影片只能讲一个观念，不可以在一张投影片里讲两个观念。</p><p>　　（3） 说明这篇论文所研究的问题的重点，以及这个问题可能和工业界的哪些应用相关。</p><p>　　（4） 清楚交代这篇论文的主要假设，主要公式，与主要应用方式（以及应用上可能的解题流程）。</p><p>　　（5） 说明这篇论文的范例（simulation examples and/or experiments），预测这个方法在不同场合时可能会有的准确度或好用的程度</p><p>　　（6） 你个人的分析、评价与批评，包括：</p><p>（6A）这篇论文最主要的创意是什么？</p><p>（6B）这些创意在应用上有什么好处？</p><p>（6C）这些创意和应用上的好处是在哪些条件下才能成立？</p><p>（6D）这篇论文最主要的缺点或局限是什么？</p><p>（6E）这些缺点或局限在应用上有什么坏处？</p><p>（6F）这些缺点和应用上的坏处是因为哪些因素而引入的？</p><p>（6G）你建议学长学弟什么时候参考这篇论文的哪些部分（点子）？</p><p>　　一般来讲，刚开始报告论文（硕一上学期）时只要做到能把前四项要素说清楚就好了，但是硕一结束后（暑假开始）必须要设法做到六项要素都能触及。硕二下学期开始的时候，必须要做到六项都能说清楚。</p><p>　　注意：读论文和报告论文时，最重要的是它的创意和观念架构，而不是数学上恒等式推导过程的细节（顶多只要抓出关键的 equation 去弩懂以及说明清楚即可）。你报告观念与分析创意，别人容易听懂又觉得有趣；你讲恒等式，大家不耐烦又浪费时间。</p>]]></content>
      
      
      <categories>
          
          <category> postgraduate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> papers reading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>目标检测mAP(mean Average Precision)</title>
      <link href="/2020/06/09/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8BmAP(mean%20Average%20Precision)/"/>
      <url>/2020/06/09/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8BmAP(mean%20Average%20Precision)/</url>
      
        <content type="html"><![CDATA[<p>​         mAP可译为平均精度均值，是目标检测中模型性能的衡量指标。多个类别的目标检测任务中，每个类别都可以根据recall（召回率）和precision（准确率）绘制一条曲线。AP可看作该曲线下的面积，而mAP就是指在求得每一类AP的基础上再计算其所有类别的平均值。</p><h2 id="1-几个概念"><a href="#1-几个概念" class="headerlink" title="1.几个概念"></a>1.几个概念</h2><ol><li><p>True Positives(TP)：实际为正例且被模型划分为正例的实例数。</p></li><li><p>False Positives(FP)：实际为负例但被模型划分为正例的实例数。</p></li><li><p>True  Negatives(TN)：实际为负例且被模型划分为负例的实例数。</p></li><li><p>False Negatives(FN)：实际为正例但被模型划分为负例的实例数。</p></li><li><p>准确率（Precision）可理解为<strong>查准率</strong>，是指在所有预测为正例的样本中，真正例所占的比例。</p><p>召回率 $(\mathrm{recall})=\frac{TP}{TP+FN}=\mathrm{R}$<br>(查全率)</p></li><li><p>召回率（Recall）可理解为<strong>查全率</strong>，是指在所有正例中被正确预测的比例。</p><p>准确率 $(\text { precision })=\frac{TP}{TP+FP}=\mathrm{P}$<br>$($ 查准率)</p><p><img src="D:\blog\public\img\post1_1.JPG" alt="post1_1" style="zoom:80%;" /></p></li></ol><h2 id="2-单类别AP"><a href="#2-单类别AP" class="headerlink" title="2.单类别AP"></a>2.单类别AP</h2><p>​        目标检测的预测结果通常包含两部分，即预测框(bounding box)和置信度P。而预测正确需要满足两个条件，①类别正确且置信度(confidence score)大于一定阈值(P_threshold)，②预测框与真实框(ground truth)的IoU大于一定阈值(IoU_threshold)。</p><p><strong>示例</strong></p><p>​         假设用训练好的模型得到所有测试样本的confidence score，每一类的confidence score保存到一个文件中，设共有20个测试样本，每个样本的id、confidence score和ground truth label如下。</p><p><img src="D:\blog\public\img\post1_2.JPG" alt="post1_2" style="zoom:80%;" /><img src="D:\blog\public\img\post1_3.JPG" alt="post1_3"></p><p>然后对confidence score 排序得到，</p><p><img src="D:\blog\public\img\post1_3.JPG" alt="post1_3"></p><p>再计算precision和recall。比如想得到top-5的结果，则相当于在设定了置信阈值的情况下，上表中前5个样本被认定为正例，其余均为负例。</p><p><img src="D:\blog\public\img\post1_4.JPG" alt="post1_4" style="zoom:80%;" /></p><p>则在这个例子中，True Positives就是指id为4和2的样本，因为它们的gt_label为1且同时被预测为正例。False Positives就是指id为13、19、6的样本。而从全表看，gt_label为1的有6个样本，即False Negatives为4个，True Negatives为15-4=11个。</p><p>因此，对于top-5而言，Precision=2/(2+3)=0.4，Recall=2/(2+4)=1/3。</p><p>在实际多类别检测任务中，通常不会只通过top-5来衡量模型的好坏，而是需要知道从top-1到top-N（N是所有测试样本个数）对应的Precision和Recall。易知，随着参与计算的样本增加，Recall会越来越大，Precision则整体呈下降趋势。把Recall作为横坐标，Precision 作为纵坐标，即可得到Precision-Recall曲线。</p><p><img src="D:\blog\public\img\post1_5.JPG" alt="post1_5" style="zoom:80%;" /></p><p>在计算AP之前，需要先将平滑化。方法是<strong>取查全率大于等于r时最大的查准率p</strong>。即，$p(r)=\max _{\tilde{r} \geq r} p(\tilde{r})$。</p><p>从而得到平滑后的曲线（下图仅为示意图）。</p><p><img src="https://pic1.zhimg.com/v2-666e46a022e32981aeb07b85958803cc_r.jpg" alt="preview" style="zoom:80%;" /></p><p>而对于AP的计算有两种方法：</p><ol><li><p>voc2010之前的方法</p><p>AP=(平滑后PR曲线上，Recall分别等于0,0.1,0.2,…,1.0等11处Precision的平均值)</p><p>$A P=\frac{1}{11} \sum_{r \subseteq{0,0.1, . ., 1.0}} p(r)$</p></li><li><p>voc2010以后的方法</p><p>AP=平滑后PR曲线下的面积</p></li></ol><h2 id="3-mAP的计算"><a href="#3-mAP的计算" class="headerlink" title="3.mAP的计算"></a>3.mAP的计算</h2><ol><li><p>voc数据集的mAP</p><p>voc数据集中的mAP计算的是IoU_threshold=0.5时各个类别AP的均值。</p></li><li><p>coco数据集的mAP</p><p>coco认为固定IoU_threshold的取值无法有效衡量对模型性能的影响。</p><p>比如A模型在IoU_threshold=0.5时，mAP=0.4，而B模型在IoU_threshold=0.7时，mAP同样为0.4。根据voc的标准，A、B模型的性能一样，但显然B模型的预测框更准确，性能更好。</p><p>故，coco计算IoU_threshold=0.5,0.55,0.6,…,0.95时的各个mAP。</p></li></ol><h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://blog.csdn.net/william_hehe/article/details/80006758" target="_blank" rel="noopener">https://blog.csdn.net/william_hehe/article/details/80006758</a></p><p><a href="https://zhuanlan.zhihu.com/p/56961620" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/56961620</a></p>]]></content>
      
      
      <categories>
          
          <category> object detection </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mAP </tag>
            
            <tag> object detection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/06/04/hello-world/"/>
      <url>/2020/06/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
